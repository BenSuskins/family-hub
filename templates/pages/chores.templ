package pages

import (
	"encoding/json"
	"fmt"
	"github.com/bensuskins/family-hub/internal/models"
	"github.com/bensuskins/family-hub/internal/repository"
	"github.com/bensuskins/family-hub/templates/layouts"
	"strconv"
	"strings"
)

type ChoreListProps struct {
	User        models.User
	Chores      []models.Chore
	Categories  []models.Category
	Users       []models.User
	UserNameMap map[string]string
	Filter      repository.ChoreFilter
}

type ChoreFormProps struct {
	User       models.User
	Categories []models.Category
	AllUsers   []models.User
	Chore      *models.Chore
	IsEdit     bool
}

templ ChoreList(props ChoreListProps) {
	@layouts.Base("Chores", props.User) {
		<div class="space-y-6">
			<div class="flex justify-between items-center">
				<h1 class="text-2xl font-bold text-gray-900">Chores</h1>
				if props.User.Role == models.RoleAdmin {
					<a href="/chores/new" class="bg-indigo-600 text-white px-4 py-2 rounded-md text-sm font-medium hover:bg-indigo-700">New Chore</a>
				}
			</div>

			<!-- Filters -->
			<form method="GET" action="/chores" class="flex flex-wrap gap-3 bg-white p-4 rounded-lg shadow">
				<select name="status" class="rounded-md border-gray-300 text-sm">
					<option value="">All Statuses</option>
					<option value="pending">Pending</option>
					<option value="completed">Completed</option>
					<option value="overdue">Overdue</option>
				</select>
				<select name="assigned_to" class="rounded-md border-gray-300 text-sm">
					<option value="">All Users</option>
					for _, u := range props.Users {
						<option value={ u.ID }>{ u.Name }</option>
					}
				</select>
				<select name="category" class="rounded-md border-gray-300 text-sm">
					<option value="">All Categories</option>
					for _, c := range props.Categories {
						<option value={ c.ID }>{ c.Name }</option>
					}
				</select>
				<button type="submit" class="bg-gray-100 text-gray-700 px-4 py-2 rounded-md text-sm font-medium hover:bg-gray-200">Filter</button>
			</form>

			<!-- Chore List -->
			<div class="bg-white shadow rounded-lg overflow-hidden">
				if len(props.Chores) == 0 {
					<div class="p-8 text-center text-gray-500">
						<p>No chores found</p>
					</div>
				} else {
					<div class="overflow-x-auto">
						<table class="min-w-full divide-y divide-gray-200">
							<thead class="bg-gray-50">
								<tr>
									<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Chore</th>
									<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Assigned To</th>
									<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Due Date</th>
									<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
									<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
								</tr>
							</thead>
							<tbody class="bg-white divide-y divide-gray-200" id="chore-list">
								for _, chore := range props.Chores {
									@ChoreRow(chore, props.User, props.UserNameMap)
								}
							</tbody>
						</table>
					</div>
				}
			</div>
		</div>
	}
}

templ ChoreRow(chore models.Chore, user models.User, userNameMap map[string]string) {
	<tr id={ "chore-" + chore.ID }>
		<td class="px-6 py-4 whitespace-nowrap">
			<div class="text-sm font-medium text-gray-900">{ chore.Name }</div>
			if chore.Description != "" {
				<div class="text-sm text-gray-500 truncate max-w-xs">{ chore.Description }</div>
			}
			if chore.RecurrenceType != models.RecurrenceNone {
				<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800">Recurring</span>
			}
		</td>
		<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
			if chore.AssignedToUserID != nil {
				{ lookupUserName(userNameMap, *chore.AssignedToUserID) }
			} else {
				<span class="text-gray-400">Unassigned</span>
			}
		</td>
		<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
			if chore.DueDate != nil {
				{ chore.DueDate.Format("Jan 2, 2006") }
				if chore.DueTime != nil {
					{ " " + *chore.DueTime }
				}
			} else {
				<span class="text-gray-400">No due date</span>
			}
		</td>
		<td class="px-6 py-4 whitespace-nowrap">
			@choreStatusBadge(chore.Status)
		</td>
		<td class="px-6 py-4 whitespace-nowrap text-sm space-x-2">
			if chore.Status != models.ChoreStatusCompleted && chore.AssignedToUserID != nil && *chore.AssignedToUserID == user.ID {
				<button
					hx-post={ fmt.Sprintf("/chores/%s/complete", chore.ID) }
					hx-target={ "#chore-" + chore.ID }
					hx-swap="outerHTML"
					class="text-green-600 hover:text-green-900 font-medium"
				>
					Complete
				</button>
			}
			if user.Role == models.RoleAdmin {
				<a href={ templ.SafeURL(fmt.Sprintf("/chores/%s/edit", chore.ID)) } class="text-indigo-600 hover:text-indigo-900">Edit</a>
				<button
					hx-post={ fmt.Sprintf("/chores/%s/delete", chore.ID) }
					hx-target={ "#chore-" + chore.ID }
					hx-swap="outerHTML"
					hx-confirm="Delete this chore?"
					class="text-red-600 hover:text-red-900"
				>
					Delete
				</button>
			}
		</td>
	</tr>
}

templ ChoreForm(props ChoreFormProps) {
	@layouts.Base(choreFormTitle(props.IsEdit), props.User) {
		<div class="max-w-2xl mx-auto">
			<h1 class="text-2xl font-bold text-gray-900 mb-6">{ choreFormTitle(props.IsEdit) }</h1>

			<form
				if props.IsEdit && props.Chore != nil {
					action={ templ.SafeURL(fmt.Sprintf("/chores/%s", props.Chore.ID)) }
				} else {
					action="/chores"
				}
				method="POST"
				class="space-y-6 bg-white shadow rounded-lg p-6"
			>
				<div>
					<label for="name" class="block text-sm font-medium text-gray-700">Name</label>
					<input
						type="text"
						id="name"
						name="name"
						required
						if props.Chore != nil {
							value={ props.Chore.Name }
						}
						class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
					/>
				</div>

				<div>
					<label for="description" class="block text-sm font-medium text-gray-700">Description</label>
					<textarea
						id="description"
						name="description"
						rows="3"
						class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
					>
						if props.Chore != nil {
							{ props.Chore.Description }
						}
					</textarea>
				</div>

				<div>
					<label for="category_id" class="block text-sm font-medium text-gray-700">Category</label>
					<select id="category_id" name="category_id" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
						<option value="">No Category</option>
						for _, cat := range props.Categories {
							<option
								value={ cat.ID }
								if props.Chore != nil && props.Chore.CategoryID != nil && *props.Chore.CategoryID == cat.ID {
									selected
								}
							>{ cat.Name }</option>
						}
					</select>
				</div>

				<div>
					<label class="block text-sm font-medium text-gray-700 mb-2">Eligible Assignees</label>
					<p class="text-xs text-gray-500 mb-2">Select which family members can be assigned this chore. If none selected, all members are eligible.</p>
					<div class="space-y-2">
						for _, u := range props.AllUsers {
							<label class="flex items-center">
								<input
									type="checkbox"
									name="assignees"
									value={ u.ID }
									if props.Chore != nil && isEligibleAssignee(props.Chore.EligibleAssignees, u.ID) {
										checked
									}
									class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
								/>
								<span class="ml-2 text-sm text-gray-700">{ u.Name }</span>
							</label>
						}
					</div>
				</div>

				<div class="grid grid-cols-1 gap-4 sm:grid-cols-2">
					<div>
						<label for="due_date" class="block text-sm font-medium text-gray-700">Due Date</label>
						<input
							type="date"
							id="due_date"
							name="due_date"
							if props.Chore != nil && props.Chore.DueDate != nil {
								value={ props.Chore.DueDate.Format("2006-01-02") }
							}
							class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
						/>
					</div>
					<div>
						<label for="due_time" class="block text-sm font-medium text-gray-700">Due Time</label>
						<input
							type="time"
							id="due_time"
							name="due_time"
							if props.Chore != nil && props.Chore.DueTime != nil {
								value={ *props.Chore.DueTime }
							}
							class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
						/>
					</div>
				</div>

				<div>
					<label for="recurrence_type" class="block text-sm font-medium text-gray-700">Recurrence</label>
					<select
						id="recurrence_type"
						name="recurrence_type"
						class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
						onchange="updateRecurrenceFields()"
					>
						<option value="none" if props.Chore != nil && props.Chore.RecurrenceType == "none" { selected }>None</option>
						<option value="daily" if props.Chore != nil && props.Chore.RecurrenceType == "daily" { selected }>Daily</option>
						<option value="weekly" if props.Chore != nil && props.Chore.RecurrenceType == "weekly" { selected }>Weekly</option>
						<option value="monthly" if props.Chore != nil && props.Chore.RecurrenceType == "monthly" { selected }>Monthly</option>
						<option value="custom" if props.Chore != nil && props.Chore.RecurrenceType == "custom" { selected }>Custom</option>
					</select>
				</div>

				<!-- Recurrence config fields (shown/hidden by JS) -->
				<div id="recurrence-fields" class="space-y-4">
					<div id="recurrence-interval-field" class="hidden">
						<label for="recurrence_interval" class="block text-sm font-medium text-gray-700">
							Repeat every
						</label>
						<div class="mt-1 flex items-center gap-2">
							<input
								type="number"
								id="recurrence_interval"
								name="recurrence_interval"
								min="1"
								value={ recurrenceInterval(props.Chore) }
								class="block w-20 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
							/>
							<span id="recurrence-interval-unit" class="text-sm text-gray-500">weeks</span>
						</div>
					</div>

					<div id="recurrence-days-field" class="hidden">
						<label class="block text-sm font-medium text-gray-700 mb-2">On days</label>
						<div class="flex flex-wrap gap-3">
							for _, day := range []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"} {
								<label class="flex items-center">
									<input
										type="checkbox"
										name="recurrence_days"
										value={ day }
										if props.Chore != nil && hasRecurrenceDay(props.Chore.RecurrenceValue, day) {
											checked
										}
										class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
									/>
									<span class="ml-1 text-sm text-gray-700">{ capitalizeDay(day) }</span>
								</label>
							}
						</div>
					</div>

					<div id="recurrence-day-of-month-field" class="hidden">
						<label for="recurrence_day_of_month" class="block text-sm font-medium text-gray-700">Day of month</label>
						<input
							type="number"
							id="recurrence_day_of_month"
							name="recurrence_day_of_month"
							min="1"
							max="31"
							value={ recurrenceDayOfMonth(props.Chore) }
							class="mt-1 block w-20 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
						/>
					</div>

					<div id="recurrence-unit-field" class="hidden">
						<label for="recurrence_unit" class="block text-sm font-medium text-gray-700">Unit</label>
						<select
							id="recurrence_unit"
							name="recurrence_unit"
							class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
						>
							<option value="days" if props.Chore != nil && recurrenceUnit(props.Chore) == "days" { selected }>Days</option>
							<option value="weeks" if props.Chore != nil && recurrenceUnit(props.Chore) == "weeks" { selected }>Weeks</option>
							<option value="months" if props.Chore != nil && recurrenceUnit(props.Chore) == "months" { selected }>Months</option>
						</select>
					</div>
				</div>

				<div class="flex items-center">
					<input
						type="checkbox"
						id="recur_on_complete"
						name="recur_on_complete"
						if props.Chore != nil && props.Chore.RecurOnComplete {
							checked
						}
						class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
					/>
					<label for="recur_on_complete" class="ml-2 block text-sm text-gray-700">Recur after completion (vs fixed schedule)</label>
				</div>

				<div class="flex justify-end space-x-3">
					<a href="/chores" class="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50">Cancel</a>
					<button type="submit" class="bg-indigo-600 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white hover:bg-indigo-700">
						if props.IsEdit {
							Update
						} else {
							Create
						}
					</button>
				</div>
			</form>
		</div>

		<script>
			function updateRecurrenceFields() {
				var type = document.getElementById('recurrence_type').value;
				var intervalField = document.getElementById('recurrence-interval-field');
				var daysField = document.getElementById('recurrence-days-field');
				var dayOfMonthField = document.getElementById('recurrence-day-of-month-field');
				var unitField = document.getElementById('recurrence-unit-field');
				var unitLabel = document.getElementById('recurrence-interval-unit');

				intervalField.classList.add('hidden');
				daysField.classList.add('hidden');
				dayOfMonthField.classList.add('hidden');
				unitField.classList.add('hidden');

				if (type === 'weekly') {
					intervalField.classList.remove('hidden');
					daysField.classList.remove('hidden');
					unitLabel.textContent = 'weeks';
				} else if (type === 'monthly') {
					intervalField.classList.remove('hidden');
					dayOfMonthField.classList.remove('hidden');
					unitLabel.textContent = 'months';
				} else if (type === 'custom') {
					intervalField.classList.remove('hidden');
					unitField.classList.remove('hidden');
					unitLabel.textContent = '';
				}
			}
			updateRecurrenceFields();
		</script>
	}
}

func lookupUserName(userNameMap map[string]string, userID string) string {
	if name, ok := userNameMap[userID]; ok {
		return name
	}
	return "Unknown"
}

func isEligibleAssignee(eligible []string, userID string) bool {
	for _, id := range eligible {
		if id == userID {
			return true
		}
	}
	return false
}

func choreFormTitle(isEdit bool) string {
	if isEdit {
		return "Edit Chore"
	}
	return "New Chore"
}

type recurrenceConfig struct {
	Interval   int      `json:"interval,omitempty"`
	Unit       string   `json:"unit,omitempty"`
	Days       []string `json:"days,omitempty"`
	DayOfMonth int      `json:"day_of_month,omitempty"`
}

func parseRecurrenceConfig(chore *models.Chore) recurrenceConfig {
	if chore == nil || chore.RecurrenceValue == "" {
		return recurrenceConfig{}
	}
	var config recurrenceConfig
	json.Unmarshal([]byte(chore.RecurrenceValue), &config)
	return config
}

func recurrenceInterval(chore *models.Chore) string {
	config := parseRecurrenceConfig(chore)
	if config.Interval > 0 {
		return strconv.Itoa(config.Interval)
	}
	return "1"
}

func recurrenceDayOfMonth(chore *models.Chore) string {
	config := parseRecurrenceConfig(chore)
	if config.DayOfMonth > 0 {
		return strconv.Itoa(config.DayOfMonth)
	}
	return ""
}

func recurrenceUnit(chore *models.Chore) string {
	config := parseRecurrenceConfig(chore)
	if config.Unit != "" {
		return config.Unit
	}
	return "days"
}

func hasRecurrenceDay(recurrenceValue string, day string) bool {
	if recurrenceValue == "" {
		return false
	}
	var config recurrenceConfig
	json.Unmarshal([]byte(recurrenceValue), &config)
	for _, d := range config.Days {
		if strings.EqualFold(d, day) {
			return true
		}
	}
	return false
}

func capitalizeDay(day string) string {
	if len(day) == 0 {
		return day
	}
	return strings.ToUpper(day[:1]) + day[1:3]
}
