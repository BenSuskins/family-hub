package pages

import (
	"fmt"
	"time"
	"github.com/bensuskins/family-hub/internal/models"
	"github.com/bensuskins/family-hub/templates/components"
	"github.com/bensuskins/family-hub/templates/layouts"
)

type MealPlannerProps struct {
	User      models.User
	WeekStart time.Time
	Days      []time.Time
	MealMap   map[string]models.MealPlan
	Recipes   []models.Recipe
}

templ MealPlanner(props MealPlannerProps) {
	@layouts.Base("Meal Planner", props.User, "/meals") {
		<div class="space-y-6">
			@components.PageHeader("Meal Planner")

			<!-- Week Navigation -->
			<div class="flex items-center justify-center space-x-4">
				<a
					href={ templ.SafeURL(fmt.Sprintf("/meals?week_start=%s", props.WeekStart.AddDate(0, 0, -7).Format("2006-01-02"))) }
					class="inline-flex items-center gap-1 text-stone-600 hover:text-stone-900 px-3 py-1 rounded-xl ring-1 ring-stone-200"
				>
					@components.IconChevronLeft("h-4 w-4")
					Prev
				</a>
				<span class="text-lg font-medium text-stone-900">
					{ mealWeekTitle(props.WeekStart) }
				</span>
				<a
					href={ templ.SafeURL(fmt.Sprintf("/meals?week_start=%s", props.WeekStart.AddDate(0, 0, 7).Format("2006-01-02"))) }
					class="inline-flex items-center gap-1 text-stone-600 hover:text-stone-900 px-3 py-1 rounded-xl ring-1 ring-stone-200"
				>
					Next
					@components.IconChevronRight("h-4 w-4")
				</a>
				<a
					href="/meals"
					class="text-indigo-600 hover:text-indigo-800 px-3 py-1 rounded-xl border border-indigo-200 text-sm font-medium"
				>This Week</a>
			</div>

			<!-- Timeline List -->
			<div class="space-y-4">
				for _, day := range props.Days {
					<div class={ "bg-white ring-1 ring-stone-100 shadow-sm rounded-xl overflow-hidden " + mealTodayBorder(day) }>
						<!-- Day Header -->
						<div class={ "px-4 py-2 bg-stone-50 border-b border-stone-200 text-sm font-medium " + mealDayHeaderTextClass(day) }>
							{ day.Format("Monday, Jan 2") }
						</div>
						<!-- Meal Rows -->
						<div class="divide-y divide-stone-100">
							for _, mealType := range mealTypes() {
								@MealRow(day.Format("2006-01-02"), mealType, lookupMeal(props.MealMap, day.Format("2006-01-02"), mealType), props.Recipes)
							}
						</div>
					</div>
				}
			</div>
		</div>
	}
}

templ MealRow(date string, mealType models.MealType, meal *models.MealPlan, recipes []models.Recipe) {
	<div id={ mealCellID(date, mealType) } class="px-4 py-3 min-h-[3.5rem] flex items-center">
		@mealRowContent(date, mealType, meal, recipes)
	</div>
}

templ mealRowContent(date string, mealType models.MealType, meal *models.MealPlan, recipes []models.Recipe) {
	<div class="flex items-center gap-3">
		<div class="flex-shrink-0 w-24">
			@components.MealTypeBadge(mealType)
		</div>
		<div class="flex-1 min-w-0">
			if meal != nil {
				<div class="flex items-center gap-2">
					<span class="text-sm text-stone-900 truncate">
						if meal.RecipeID != nil {
							<a href={ templ.SafeURL(fmt.Sprintf("/recipes/%s", *meal.RecipeID)) } class="text-indigo-600 hover:text-indigo-800 underline">
								{ meal.Name }
							</a>
						} else {
							{ meal.Name }
						}
					</span>
					if meal.Notes != "" {
						<span class="text-xs text-stone-400 truncate hidden sm:inline">{ meal.Notes }</span>
					}
				</div>
			} else {
				<span class="text-sm text-stone-400">&mdash;</span>
			}
		</div>
		<div class="flex-shrink-0 flex items-center gap-1">
			if meal != nil {
				<button
					type="button"
					hx-get={ fmt.Sprintf("/meals/cell?date=%s&meal_type=%s&edit=true", date, string(mealType)) }
					hx-target={ "#" + mealCellID(date, mealType) }
					hx-swap="innerHTML"
					class="inline-flex items-center gap-0.5 text-xs text-stone-500 hover:text-stone-700 px-2 py-1 rounded hover:bg-stone-50"
				>
					@components.IconPencil("h-3 w-3")
					<span class="hidden sm:inline">Edit</span>
				</button>
				<form
					hx-post="/meals/delete"
					hx-target={ "#" + mealCellID(date, mealType) }
					hx-swap="innerHTML"
				>
					<input type="hidden" name="date" value={ date }/>
					<input type="hidden" name="meal_type" value={ string(mealType) }/>
					<button type="submit" class="inline-flex items-center gap-0.5 text-xs text-red-500 hover:text-red-700 px-2 py-1 rounded hover:bg-red-50">
						@components.IconTrash("h-3 w-3")
						<span class="hidden sm:inline">Clear</span>
					</button>
				</form>
			} else {
				<button
					type="button"
					hx-get={ fmt.Sprintf("/meals/cell?date=%s&meal_type=%s&edit=true", date, string(mealType)) }
					hx-target={ "#" + mealCellID(date, mealType) }
					hx-swap="innerHTML"
					class="inline-flex items-center gap-0.5 text-xs text-indigo-600 hover:text-indigo-800 px-2 py-1 rounded hover:bg-indigo-50"
				>
					@components.IconPlus("h-3 w-3")
					Add
				</button>
			}
		</div>
	</div>
}

templ MealCellEdit(date string, mealType models.MealType, meal *models.MealPlan, recipes []models.Recipe) {
	<form
		hx-post="/meals"
		hx-target={ "#" + mealCellID(date, mealType) }
		hx-swap="innerHTML"
		class="py-2 space-y-3"
	>
		<input type="hidden" name="date" value={ date }/>
		<input type="hidden" name="meal_type" value={ string(mealType) }/>

		<div class="flex items-center gap-2 text-xs text-stone-500">
			@components.MealTypeBadge(mealType)
			<span>{ mealEditDateLabel(date) }</span>
		</div>

		<!-- Freeform input (default) -->
		<div class="meal-freeform-input">
			<input
				type="text"
				class="w-full rounded-lg border-stone-200 shadow-sm text-sm"
				placeholder="e.g. Spaghetti Bolognese"
				oninput="this.form.querySelector('input[name=name]').value = this.value"
				if meal != nil && meal.RecipeID == nil {
					value={ meal.Name }
				}
			/>
		</div>

		<!-- Recipe select (hidden by default) -->
		<div class="meal-recipe-select hidden">
			<select name="recipe_id" class="w-full rounded-lg border-stone-200 shadow-sm text-sm" onchange="updateMealName(this)">
				<option value="">Select recipe...</option>
				for _, recipe := range recipes {
					<option
						value={ recipe.ID }
						data-title={ recipe.Title }
						if meal != nil && meal.RecipeID != nil && *meal.RecipeID == recipe.ID {
							selected
						}
					>{ recipe.Title }</option>
				}
			</select>
		</div>

		<input type="hidden" name="name"
			if meal != nil {
				value={ meal.Name }
			}
		/>

		<div class="flex items-center justify-between">
			<button type="button" onclick="toggleMealMode(this)" class="meal-mode-toggle text-xs text-stone-500 hover:text-stone-700">
				Use a recipe instead
			</button>
			<div class="flex gap-2">
				<button
					type="button"
					hx-get={ fmt.Sprintf("/meals/cell?date=%s&meal_type=%s", date, string(mealType)) }
					hx-target={ "#" + mealCellID(date, mealType) }
					hx-swap="innerHTML"
					class="text-xs text-stone-500 hover:text-stone-700 px-3 py-1.5"
				>Cancel</button>
				<button type="submit" class="bg-indigo-600 text-white px-3 py-1.5 rounded-lg text-xs font-medium hover:bg-indigo-700">Save</button>
			</div>
		</div>

		<div class="hidden">
			<input
				type="text"
				name="notes"
				placeholder="Notes (optional)"
				class="w-full rounded-lg border-stone-200 shadow-sm text-sm"
				if meal != nil {
					value={ meal.Notes }
				}
			/>
		</div>
	</form>

	<script>
		function toggleMealMode(btn) {
			var form = btn.closest('form');
			var freeform = form.querySelector('.meal-freeform-input');
			var recipe = form.querySelector('.meal-recipe-select');
			var toggle = form.querySelector('.meal-mode-toggle');
			if (recipe.classList.contains('hidden')) {
				recipe.classList.remove('hidden');
				freeform.classList.add('hidden');
				toggle.textContent = 'Enter name instead';
			} else {
				recipe.classList.add('hidden');
				freeform.classList.remove('hidden');
				toggle.textContent = 'Use a recipe instead';
			}
		}
		function updateMealName(select) {
			var form = select.closest('form');
			var selected = select.options[select.selectedIndex];
			if (selected && selected.dataset.title) {
				form.querySelector('input[name=name]').value = selected.dataset.title;
			}
		}
		// Initialize mode for edit: if meal has a recipe, show recipe mode
		(function() {
			var form = document.querySelector('[hx-post="/meals"]:last-of-type') || document.querySelector('form[hx-post="/meals"]');
			if (!form) return;
			var recipeSelect = form.querySelector('select[name=recipe_id]');
			if (recipeSelect && recipeSelect.value) {
				toggleMealMode(form.querySelector('.meal-mode-toggle'));
			}
		})();
	</script>
}

// MealCell renders a non-edit meal row (used by handler for HTMX responses)
templ MealCell(date string, mealType models.MealType, meal *models.MealPlan, recipes []models.Recipe) {
	@mealRowContent(date, mealType, meal, recipes)
}

func mealCellID(date string, mealType models.MealType) string {
	return fmt.Sprintf("meal-%s-%s", date, string(mealType))
}

func mealTypes() []models.MealType {
	return []models.MealType{models.MealTypeBreakfast, models.MealTypeLunch, models.MealTypeDinner}
}

func mealTypeLabel(mealType models.MealType) string {
	switch mealType {
	case models.MealTypeBreakfast:
		return "Breakfast"
	case models.MealTypeLunch:
		return "Lunch"
	case models.MealTypeDinner:
		return "Dinner"
	}
	return string(mealType)
}

func mealWeekTitle(weekStart time.Time) string {
	end := weekStart.AddDate(0, 0, 6)
	if weekStart.Month() == end.Month() {
		return fmt.Sprintf("%s %d - %d, %d", weekStart.Month().String(), weekStart.Day(), end.Day(), weekStart.Year())
	}
	return fmt.Sprintf("%s %d - %s %d, %d", weekStart.Month().String()[:3], weekStart.Day(), end.Month().String()[:3], end.Day(), end.Year())
}

func mealDayHeaderTextClass(day time.Time) string {
	today := time.Now()
	if day.Year() == today.Year() && day.Month() == today.Month() && day.Day() == today.Day() {
		return "text-indigo-600"
	}
	return "text-stone-900"
}

func mealTodayBorder(day time.Time) string {
	today := time.Now()
	if day.Year() == today.Year() && day.Month() == today.Month() && day.Day() == today.Day() {
		return "ring-indigo-300"
	}
	return ""
}

func mealEditDateLabel(date string) string {
	parsed, err := time.Parse("2006-01-02", date)
	if err != nil {
		return date
	}
	return parsed.Format("Mon, Jan 2")
}

func lookupMeal(mealMap map[string]models.MealPlan, date string, mealType models.MealType) *models.MealPlan {
	key := date + "-" + string(mealType)
	if meal, ok := mealMap[key]; ok {
		return &meal
	}
	return nil
}
